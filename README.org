* dockman - Docker Manager Tool 
** Introduction 

This tool simplifies using of docker containers for testing and
exploring programming languages toolchain; compilers and servers
encapsulated in containers. Dockman is wrapper around 'docker' client
with convenient command line switches and default converntions which
makes easier to use development tools from docker image. 

By using containers, the user can access a full-featured toolchain for a
given programming language without any installation effort or running
the risk of currently installed toolchain. For instance, it is far
easier and faster to run a new GCC (GNU C) compiler version from a
container than installing it on the current machine risking breaking
the current GCC installation. 
** Examples 
*** Show help

#+BEGIN_SRC sh 
  $ ./dockman.bin --help

   dockman - Docker Manager Tool

  Usage: $ dockman <SUBCOMMAND> <DOCKER-IMAGE> [<OPTIONS>...]

   => Run docker-image unix shell (REPL) or any other entrypoint.
   $ dockman shell <DOCKER-IMAGE> [<OPTIONS>...] 

   => Run docker-image as daemon (aka service) 
   $ dockman daemon <DOCKER-IMAGE> [<OPTIONS>...] 

   => Build docker image from file 
   $ dockman build <DOCKER-IMAGE=-NAME> <DOCKER-FILE>

   Options:
        --verbose Log docker commands for debugging.
  -w    --workdir Working directory, default current directory of host.
  -n       --name Human-readable name for container.
  -c    --command Command to be executed by image entrypoint
  -e --entrypoint Alternative entrypoint.
  -x        --x11 Enable X11 GUI graphical user interface
  -u       --user Alternative user.
  -m       --home Mount $HOME directory to /uhome dir. in container.
  -v     --volume Volume to be mounted.
  -h       --help This help information.
#+END_SRC
*** Running shell (bash) in a docker-image with D-Language compiler

Get current directory and list it (before running docker image)

#+BEGIN_SRC sh 
  $ pwd
  /home/archbox/Documents/projects/dockman.dlang

  # List files of current directory 
  $ ls
  dockman.bin*  dockman.d  dockman.o  Makefile  README.org
#+END_SRC

Run shell (bash) in docker image 'docker.io/dlangchina/dlang-dmd'
mounting current directory to the '/work' directory in the container
which is set as the current working directory. 

#+BEGIN_SRC sh 
  $ ./dockman.bin shell docker.io/dlangchina/dlang-dmd --verbose

   [TRACE] Mount /home/archbox/Documents/projects/dockman.dlang to /work 
   [TRACE] Mount /home/archbox to /uhome 
   Docker command run: 
   ["docker", "run", "-it", "--rm", "-v", "/home/archbox/Documents/projects/dockman.dlang:/work", "-w", "/work", "docker.io/dlangchina/dlang-dmd"]
   root@c8dbe6974808:/work# 

   root@c8dbe6974808:/work# pwd

   root@c8dbe6974808:/work# ls
   Makefile  README.org  dockman.bin  dockman.d  dockman.o
#+END_SRC

Check DMD compiler. 

#+BEGIN_SRC sh 
  root@c8dbe6974808:/work# dmd --version
  DMD64 D Compiler v2.091.1
  Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved written by Walter Bright
#+END_SRC

Build dockman.d with the Docker container shell.

#+BEGIN_SRC sh 
  # Compile 
  #---------------------------------------------------------
  root@c8dbe6974808:/work# dmd dockman.d -of=dockman.elf

  # Test 
  #---------------------------------------------------------
  root@c8dbe6974808:/work# ./dockman.elf 
   dockman - Docker Manager Tool

  Usage: $ dockman <SUBCOMMAND> <DOCKER-IMAGE> [<OPTIONS>...]

   => Run docker-image unix shell (REPL) or any other entrypoint.
   $ dockman shell <DOCKER-IMAGE> [<OPTIONS>...] 

  ... ... ... ... ... ... ... ... ... ... ... ... 
  ... ... ... ... ... ... ... ... ... ... ... ... 

#+END_SRC

*** Docker image with Julia Language and chart plotting (X11 GUI Forwarding)

 *Example A:*

The following command runs the docker image
docker.io/terasakisatoshi/myjulia' which contains a [[https://en.wikipedia.org/wiki/Julia_(programming_language)][Julia language]] 
REPL with PyPlot and Plots plotting packages. The (-x) command line
switch, equivlant to (--x11) enables X11 forwarding which allows
running GUI graphical user interface applications such as chart
pannels, IDEs and so on.

#+BEGIN_SRC julia 
  $ ./dockman.bin shell docker.io/terasakisatoshi/myjulia -x 
                 _
     _       _ _(_)_     |  Documentation: https://docs.julialang.org
    (_)     | (_) (_)    |
     _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)
   _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
  |__/                   |

   julia> x = 0:2:10
   0:2:10

   julia> y = @. x^2 - 4x + 10
   6-element Array{Int64,1}:
    10
     6
    10
    22
    42
    70

   julia> import PyPlot; plt = PyPlot;

   julia> plt.plot(x, y)
   QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to '/tmp/runtime-root'
   libGL error: MESA-LOADER: failed to retrieve device information
   libGL error: unable to load driver: i915_dri.so
   libGL error: driver pointer missing
   libGL error: failed to load driver: i915
   libGL error: failed to open drm device: No such file or directory
   libGL error: failed to load driver: i965
   libGL error: unable to load driver: swrast_dri.so
   libGL error: failed to load driver: swrast
   1-element Array{PyCall.PyObject,1}:
    PyObject <matplotlib.lines.Line2D object at 0x7f6768fe5278>

  julia> readdir()
  8-element Array{String,1}:
   ".git"       
   ".gitignore" 
   "Makefile"   
   "README.org" 
   "dockman.bin"
   "dockman.d"  
   "dockman.elf"
   "dockman.o"
#+END_SRC

 *Example B:* 

Run previous command with flag (--verbose) for debugging purposes and
working directory, which the default value is the current directory,
set to '/etc' directory of host machine.

#+BEGIN_SRC sh 
   $ ./dockman.bin shell docker.io/terasakisatoshi/myjulia -x -w=/etc --verbose 
    [TRACE] Mount /etc to /work 
    [TRACE] Enable X11 - graphical user interfaces 
    Docker command run: 
    ["docker", "run", "-it", "--rm", "-v", "/etc:/work", "-w", "/work", "-e", "DISPLAY", "-v", "/tmp/.X11-unix:/tmp/.X11-unix", "-v", "/home/archbox/.Xauthority:/root/.Xauthority", "docker.io/terasakisatoshi/myjulia"]
                  _
      _       _ _(_)_     |  Documentation: https://docs.julialang.org
     (_)     | (_) (_)    |
      _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
     | | | | | | |/ _` |  |
     | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)
    _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
   |__/                   |

   julia> readdir()
   357-element Array{String,1}:
    ".java"                  
    ".pwd.lock"              
    ".updated"               
    "DIR_COLORS"             
    "DIR_COLORS.256color"    
    "DIR_COLORS.lightbgcolor"
    "GREP_COLORS"            
    "ImageMagick-6"          
    "NetworkManager"         
    â‹®                        
    "yum"                    
    "yum.repos.d"            
    "zfs-fuse"               
    "zlogin"                 
    "zlogout"                
    "zprofile"               
    "zshenv"                 
    "zshrc"                  

#+END_SRC

*** Docke image for compiling and running TypeScript 

This example uses the following alpine-based Docker image for
compiling and running typescript [[https://hub.docker.com/r/sandrokeil/typescript][sandrokeil/typescript]] (source code:
[[https://github.com/sandrokeil/docker-files/blob/master/typescript/Dockerfile][typescript/Dockerfile]]). This Docker image contains pre-installed
NodeJS, npm and TSC - typescript compiler.


 + File: test.ts  - Typescript source to be compiled. 

#+BEGIN_SRC cpp
   class MetaObject{
         constructor (public Name: string){ }
   }

   let obj1 = new MetaObject("Something");
   let obj2 = new MetaObject("Else");

   console.log(" =>> Hello world typescript ");
   console.log(`\t Obj = ${obj1.Name} `);

   for (let j of  [10, 9, 100, 52]){
     console.log(`j = ${j}`);
   }
#+END_SRC


  *Compile typescript with docker image in interactive mode*

 + Note: It is assumed that the file 'test.ts' is in the current directory.
 + '-e=sh', equivalent to '--entrypoint=sh' changes the current
   container entrypoint. 

#+BEGIN_SRC sh 
  $ dockman shell sandrokeil/typescript -e=sh
  /work $ 
  /work $ ls
  test.ts
#+END_SRC

Compile and check generated files: 

#+BEGIN_SRC sh 
  # Compile to Javascript =>> Generates test.js
  /work $ tsc test.ts 

  # Check generated files 
  /work $ ls
  test.js  test.ts

  # Show content of compiled javascript "Object-code"
  /work $ cat test.js

  var MetaObject = /** @class */ (function () {
      function MetaObject(Name) {
          this.Name = Name;
      }
      return MetaObject;
  }());
  var obj1 = new MetaObject("Something");
  var obj2 = new MetaObject("Else");
  console.log(" =>> Hello world typescript ");
  console.log("\t Obj = " + obj1.Name + " ");
  for (var _i = 0, _a = [10, 9, 100, 52]; _i < _a.length; _i++) {
      var j = _a[_i];
      console.log("j = " + j);
  }
#+END_SRC

Run compiled typescript: 

#+BEGIN_SRC sh 
  /work $ node test.js

   =>> Hello world typescript 
           Obj = Something 
  j = 10
  j = 9
  j = 100
  j = 52
#+END_SRC

 *Compile typescript with docker image in batch mode*

Compilation: generates test.js 

#+BEGIN_SRC sh 
  $ dockman shell sandrokeil/typescript -c="tsc test.ts"
#+END_SRC

Running with nodeJS: 

#+BEGIN_SRC sh 
  $ dockman shell sandrokeil/typescript -c="node test.js"
   =>> Hello world typescript 
           Obj = Something 
  j = 10
  j = 9
  j = 100
  j = 52
#+END_SRC

Running with nodeJS: (Show docker command line swiches in verbose mode)

#+BEGIN_SRC sh 
  $ dockman shell sandrokeil/typescript -c="node test.js" --verbose

   [TRACE] Mount /home/archbox/Documents/projects/dockman.dlang/test to /work 
   Docker command run: 
   ["docker", "run", "-it", "--rm", "-v", "/home/user/test:/work", "-w", "/work", "sandrokeil/typescript", "node", "test.js"]

   =>> Hello world typescript 
           Obj = Something 
  j = 10
  j = 9
  j = 100
  j = 52
#+END_SRC

** Building Instructions

Dockman is written in [[https://en.wikipedia.org/wiki/D_(programming_language)][D programming language]] and has the following
compilation options: 

 *Building* 

 + Option 1:
   + Compilation with system-installed *DMD* (D-Language compiler). 

#+BEGIN_SRC sh 
  $ make build1 

  # Show help 
  $ ./dockman.bin --help
#+END_SRC

 + Option 2: Compilation using the Docker image
   + The advantage of this option is that the D-language tooling don't
     need to be installed in the system as the toolings are provided
     by docker image [[https://github.com/dlangchina/docker-dlang][dlangchina/docker-dlang]]. It only needs a _docker_
     instalation. 

#+BEGIN_SRC sh 
  $ make build2 

  # Show help 
  $ ./dockman.bin --help
#+END_SRC

 *Installing* 

The binary can become accessible from command line from any directory,
if it is placed in any folder listed in $PATH variable, for instance
/bin or /usr/bin.

Another way to install locally without root access is to use the
following commands:

#+BEGIN_SRC sh 
  $ make build1 
  $ mkdir -p ~/bin && cp dockman.bin ~/bin/dockman 
  # Add ~/bin directory to ~/.bashrc 
  $ echo "export PATH=$$PATH:~/bin" >> ~/.bashrc 
#+END_SRC

